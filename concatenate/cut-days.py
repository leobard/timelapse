#!/usr/bin/python

"""

# Cut days out from a multi-day video

Summary:
Input are videos generated by timelapse-prepare-and-run-ffmpeg.sh
- 25 fps; 0.04seconds per frame
- 5 minutes between frames. 125 minutes per second, 2h 5m per second.
- one frame is one photo
- each frame is described in the accompanied SRT file

Requirements:
pip install -U srt
ffmpeg
"""
import srt
import subprocess 
import os
import sys
import datetime

class SRTWriter:
    def __init__(self):
        # frame-counter
        self.frame_counter = 0
        # begin time of last frame
        self.last_time = None
        # start with an empty list of srt.Subtitle 
        self.subs = [] 
    
    def add_day():
        """
        
        """
        


def get_duration(input_video):
    cmd = ["ffprobe", "-i", input_video, "-show_entries", "format=duration",
           "-v", "quiet", "-sexagesimal", "-of", "csv=p=0"]
    return subprocess.check_output(cmd).decode("utf-8").strip()

def ffmpeg_cut_part(input_filename, ss, to, output_filename):
    '''
    use ffmpeg to cut a part from input_filename into output_filename. 
    timing is passed as "ss" and "to" times as defined by ffmpeg copy command
      example:00:00:05.040
    
    hints:
    - not using "-vcodec copy"
    
    Test on 2024-10-04
    - duration of test file is the same as the duration in the srt file
      ffprobe -i 2021-09-17.mp4 -show_entries format=duration  ==> duration=11.520000
      2021-09-17.srt ==> 00:00:11,520
    '''
    if os.path.isfile(output_filename):
        os.remove(output_filename)
    # Key-Frame problem: just copying doesn't cut it for the frame-based cuts needed
    # cmd = ["ffmpeg", "-i", name, "-ss", time[0], "-to", time[1], "-c:v", "copy", "-c:a", "copy", output_filename]
    cmd = ["ffmpeg", 
        # https://superuser.com/questions/326629/how-can-i-make-ffmpeg-be-quieter-less-verbose
        "-hide_banner", "-loglevel", "error", "-nostats",
        "-i", input_filename, 
        "-ss", ss, 
        "-to", to, 
        output_filename]
    
    # run the command
    # subprocess.check_output(cmd) # this would print the output
    completed = subprocess.run(cmd)
    if completed.returncode == 0:
        print("Created video file: '"+output_filename+"'")
    else:
        # error and print the command
        print("Error creating video file. The following command was used: ")
        cmd_print = [("\""+c+"\"" if (" " in c) else c) for c in cmd]
        print (" ".join(cmd_print))
        print()

def timedelta_to_fftime(timedelta):
    '''
    convert a :py:class:`datetime.timedelta to a time that can be used by ffmpeg
    '''
    return str(timedelta)


def process_srt_create_outputs(srt_generator, video_filename, interestingdays, output_pathname):
    '''
    go through srt_generator stream to find days that are within interestingdays,
    for each interestingday:
    - create new mp4 file by using ffmpeg commandline on the video_filename
    - create new srt file
    '''    
    current_day = None
    current_interestingday = False
    # List of :py:class:`Subtitle`
    current_srtbuffer = []
    # from the current day, the Subtitle.start :py:class:`datetime.timedelta
    current_start_time = None
    current_end_time = None
    
    def if_interesting_create_outputs():
        '''
        check if this is current_interestingday, if it is:
        for the current interesting day found in srt and video files, write the output to srt and mp4 files
        
        inner function to reuse code
        
        '''
        if (current_day is not None) and current_interestingday:
        
            # write srt file
            srt_outfilename = os.path.join(output_pathname, current_day + ".srt");
            with open(srt_outfilename, "w") as srt_outfile:
                srt_outfile.write(srt.compose(current_srtbuffer))
            print("Created subtitle file: '"+srt_outfilename+"'")
            
            # cut and write mp4
            mp4_outfilename = os.path.join(output_pathname, current_day + ".mp4");
            ffmpeg_cut_part(video_filename, 
                timedelta_to_fftime(current_start_time),
                timedelta_to_fftime(current_end_time),
                mp4_outfilename)
    
    
    for subtitle in srt_generator:
        # example: 2021-09-05 00:12
        subt_day = subtitle.content[0:10]
        if (current_day is None) or (current_day != subt_day):
            # finalize old day if it was interesting
            if_interesting_create_outputs()                
            
            # initialize new current_day
            current_day = subt_day
            if current_day in interestingdays:
                current_interestingday = True
                current_srtbuffer = []
                current_start_time = subtitle.start
                print("Found interesting day: "+current_day)
            else: 
                current_interestingday = False
            
                
        # handle Subtitle
        if current_interestingday:
            # change timing, relative to new file
            output_subtitle = srt.Subtitle(
                index = None,
                start = subtitle.start - current_start_time,
                end = subtitle.end - current_start_time,
                content = subtitle.content,
                proprietary = subtitle.proprietary
            )
            current_srtbuffer.append(output_subtitle)
            current_end_time = subtitle.end
    
    # after iterating through all SRTs : finalize this day if it was interesting
    if_interesting_create_outputs()


def process_srt_cut_within_day(srt_generator, video_filename, interestingdays, output_pathname):
    '''
    go through srt_generator stream to find days that are within interestingdays,
    for each interestingday:
    - create new mp4 file by using ffmpeg commandline on the video_filename
    - create new srt file
    
    INTRADAY VERSION - interestingdays is sorted and contains time marks which should be used to cut the whole files into parts. Start and End Marks must be provided.
    
    ''' 
    interesting_idx = -1
    interesting_start = None
    interesting_end = None
    
    # List of :py:class:`Subtitle`
    current_srtbuffer = []
    # from the current day, the Subtitle.start :py:class:`datetime.timedelta
    current_start_time = datetime.timedelta(0)
    current_end_time = datetime.timedelta(0)
    
    def create_outputs():
        '''
        for the current slot, write the output to srt and mp4 files
        
        inner function to reuse code
        
        '''
        # clean filename, no ":" and " " in filenames for mp4 concat
        interesting_start_filename = interesting_start.replace(":", "").replace(" ","_")
        # write srt file
        srt_outfilename = os.path.join(output_pathname, interesting_start_filename + ".srt");
        with open(srt_outfilename, "w") as srt_outfile:
            srt_outfile.write(srt.compose(current_srtbuffer))
        print("Created subtitle file: '"+srt_outfilename+"'")
        
        # cut and write mp4
        mp4_outfilename = os.path.join(output_pathname, interesting_start_filename + ".mp4");
        ffmpeg_cut_part(video_filename, 
            timedelta_to_fftime(current_start_time),
            timedelta_to_fftime(current_end_time),
            mp4_outfilename)
    
    def next_interesting_slot():
        '''
        Load the next interesting time slot from interestingdays
        '''
        nonlocal interesting_idx, interesting_start, interesting_end, current_start_time
        if interesting_idx == -1:
            interesting_idx = 0
        else:
            if interesting_idx == len(interestingdays)-2:
                # this was the last interesting slot
                return False
            else:
                interesting_idx = interesting_idx + 1
        interesting_start = interestingdays[interesting_idx]
        interesting_end = interestingdays[interesting_idx+1]
        return True
    
    # init next_interesting_slot
    next_interesting_slot()
    
    for subtitle in srt_generator:        
        if subtitle.content > interesting_end:
            # finalize current slot
            create_outputs()                
            
            # go to next_interesting_slot
            next_interesting_slot()
            current_srtbuffer = []
            current_start_time = subtitle.start            
        
        # handle Subtitle
        # change timing, relative to new file
        output_subtitle = srt.Subtitle(
            index = None,
            start = subtitle.start - current_start_time,
            end = subtitle.end - current_start_time,
            content = subtitle.content,
            proprietary = subtitle.proprietary
        )
        current_srtbuffer.append(output_subtitle)
        current_end_time = subtitle.end
    
    # finalize current slot
    create_outputs()

def load_interestingdays(interestingdays_filename):
    '''
    Load interesting days from filename. 
    Keep them in ISO Format, as array
    '''
    print("reading interesting days from '"+interestingdays_filename+"'")
    with open(interestingdays_filename, "r") as f:
        interestingdays = f.readlines()
        
    # remove the tailing \n using rstrip
    interestingdays = [d.rstrip('\n') for d in interestingdays]
    return interestingdays


def main():
    '''
    see usage 
    '''
    
    if 5 != len(sys.argv):
        # usage
        print('Cut a SRT and according mp4 into day files (yyyy-mm-dd.srt and yyyy-mm-dd.mp4) according to the timestamps in according SRT subtitles. ')
        print('Usage: python cut-days.py <srt_filename> <video_filename> <interestingdays_filename> <output_pathname>')
        print('example: ')
        print('python cut-days.py "2021-09-12 to 09-18 timelapse_1080.srt" "2021-09-12 to 09-18 timelapse_1080.mp4" "interesting_days.txt" "output"')
        sys.exit(2)    
    
    srt_filename = sys.argv[1]
    video_filename = sys.argv[2]
    interestingdays_filename = sys.argv[3]
    output_pathname = sys.argv[4]
    
    interestingdays = load_interestingdays(interestingdays_filename)
    
    if not os.path.isdir(output_pathname):
        os.makedirs(output_pathname)
    
    # is this file a special case of intra-day cutting?
    interestingdays_intraday = "_intraday" in interestingdays_filename
    
    print("reading SRT from '"+srt_filename+"'")
    with open(srt_filename, "r") as srt_file:
        print("writing to "+output_pathname)
        srt_generator = srt.parse(srt_file)
        if interestingdays_intraday:
            print("SPECIAL CASE: intraday")
            process_srt_cut_within_day (srt_generator, video_filename, interestingdays, output_pathname)
        else:
            process_srt_create_outputs (srt_generator, video_filename, interestingdays, output_pathname)


if __name__ == "__main__":
    main()